{"meta":{"title":"ZX's Blog","subtitle":null,"description":"Inspired Technology","author":"ZX","url":"http://Mrzhhh.github.io"},"pages":[{"title":"[404 Not Found]","date":"2018-02-16T15:15:13.000Z","updated":"2018-02-17T04:26:19.000Z","comments":true,"path":"404.html","permalink":"http://Mrzhhh.github.io/404.html","excerpt":"","text":""},{"title":"ABOUT","date":"2018-02-16T15:15:13.000Z","updated":"2018-03-13T21:19:38.513Z","comments":false,"path":"about/index.html","permalink":"http://Mrzhhh.github.io/about/index.html","excerpt":"","text":"一个默默无闻的文艺青年。"},{"title":"CATEGORIES","date":"2018-02-18T13:16:52.000Z","updated":"2018-02-19T02:42:00.000Z","comments":false,"path":"categories/index.html","permalink":"http://Mrzhhh.github.io/categories/index.html","excerpt":"","text":""},{"title":"TAGS","date":"2018-02-18T13:12:23.000Z","updated":"2018-02-19T02:41:42.000Z","comments":false,"path":"tags/index.html","permalink":"http://Mrzhhh.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"从人脸图片库中筛选正脸姿态图片","slug":"2018-06-27从人脸图片库中筛选正脸姿态图片","date":"2018-06-26T16:00:00.000Z","updated":"2018-06-27T06:52:18.207Z","comments":true,"path":"2018/06/27/2018-06-27从人脸图片库中筛选正脸姿态图片/","link":"","permalink":"http://Mrzhhh.github.io/2018/06/27/2018-06-27从人脸图片库中筛选正脸姿态图片/","excerpt":"介绍本文主要介绍一个小工具，其功能是在具有各种姿态（各个角度的转头）的人脸图片库中筛选出正脸的图片。","text":"介绍本文主要介绍一个小工具，其功能是在具有各种姿态（各个角度的转头）的人脸图片库中筛选出正脸的图片。 环境需求SeetaFace人脸识别库 基本方法首先使用OpenCV的glob遍历文件夹里的图片，然后对每张图片提取脸部特征。以下这段代码为提取脸部特征点，如图所示： 1234567891011121314151617181920212223242526272829Mat frame = imread(fn[i]); if (!frame.data) &#123; continue; &#125; images.push_back(frame); seeta::FaceDetector2 FD(&quot;bindata/SeetaFaceDetector2.0.ats&quot;); seeta::cv::ImageData image = frame; seeta::PointDetector2 PD(&quot;bindata/SeetaPointDetector2.0.pts5.ats&quot;); int num; SeetaRect *face = FD.Detect(image, &amp;num); if (num==0) &#123; continue; &#125; SeetaPointF *points = PD.Detect(image, *face); if (points) &#123; std::cout &lt;&lt; &quot;Points: [&quot; &lt;&lt; std::endl; for (int j = 0; j &lt; PD.LandmarkNum(); ++j) &#123; std::cout &lt;&lt; &quot;(&quot; &lt;&lt; points[j].x &lt;&lt; &quot;, &quot; &lt;&lt; points[j].y &lt;&lt; &quot;),&quot; &lt;&lt; std::endl; &#125; std::cout &lt;&lt; &quot;]&quot; &lt;&lt; std::endl; &#125; 然后计算点3是否为点1和点二的中点，如果是的话，则判断为正脸照片。123456789double result = 2 * points[2].x - points[0].x - points[1].x; result = fabs(result); if (result &lt; s) &#123; s = result; std::cout &lt;&lt; s &lt;&lt; std::endl; string Img_Name = &quot;D:/Desktop/pachong/result/&quot; + to_string(s) + &quot;.jpg&quot;; imwrite(Img_Name, frame); &#125; 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;seeta/FaceDetector2.h&gt;#include&lt;seeta/PointDetector2.h&gt;#include&lt;seeta/FaceRecognizer.h&gt;#include&lt;opencv2/opencv.hpp&gt;#include&lt;seeta/Struct_cv.h&gt;#include&lt;iostream&gt;#include&lt;io.h&gt;#include&lt;string&gt;#include&lt;vector&gt;using namespace std;using namespace cv;void main()&#123; vector&lt;Mat&gt; read_images_in_folder(cv::String pattern); cv::String pattern = &quot;你的图片文件路径&quot;; vector&lt;Mat&gt; images = read_images_in_folder(pattern);&#125;std::vector&lt;Mat&gt; read_images_in_folder(cv::String pattern)&#123; vector&lt;cv::String&gt; fn; glob(pattern, fn, false); cout &lt;&lt; &quot;pattern&quot;&lt;&lt;pattern &lt;&lt; endl; vector&lt;Mat&gt; images; size_t count = fn.size(); cout &lt;&lt; count &lt;&lt; endl; double s = 20; int pick_img = 0; for (size_t i = 0; i &lt; count; i++) &#123; Mat frame = imread(fn[i]); if (!frame.data) &#123; continue; &#125; images.push_back(frame); seeta::FaceDetector2 FD(&quot;bindata/SeetaFaceDetector2.0.ats&quot;); seeta::cv::ImageData image = frame; seeta::PointDetector2 PD(&quot;bindata/SeetaPointDetector2.0.pts5.ats&quot;); int num; SeetaRect *face = FD.Detect(image, &amp;num); if (num==0) &#123; continue; &#125; SeetaPointF *points = PD.Detect(image, *face); if (points) &#123; std::cout &lt;&lt; &quot;Points: [&quot; &lt;&lt; std::endl; for (int j = 0; j &lt; PD.LandmarkNum(); ++j) &#123; std::cout &lt;&lt; &quot;(&quot; &lt;&lt; points[j].x &lt;&lt; &quot;, &quot; &lt;&lt; points[j].y &lt;&lt; &quot;),&quot; &lt;&lt; std::endl; &#125; std::cout &lt;&lt; &quot;]&quot; &lt;&lt; std::endl; &#125; double result = 2 * points[2].x - points[0].x - points[1].x; result = fabs(result); if (result &lt; s) &#123; s = result; std::cout &lt;&lt; s &lt;&lt; std::endl; string Img_Name = &quot;D:/Desktop/pachong/result/&quot; + to_string(s) + &quot;.jpg&quot;; imwrite(Img_Name, frame); &#125; &#125; return images;&#125;","categories":[{"name":"Technology","slug":"Technology","permalink":"http://Mrzhhh.github.io/categories/Technology/"}],"tags":[{"name":"Face Recognition","slug":"Face-Recognition","permalink":"http://Mrzhhh.github.io/tags/Face-Recognition/"}]},{"title":"Tensorflow读取本地图片数据的实现","slug":"tensorflow读取本地图片数据的实现","date":"2018-06-12T09:30:31.000Z","updated":"2018-06-12T09:30:44.607Z","comments":true,"path":"2018/06/12/tensorflow读取本地图片数据的实现/","link":"","permalink":"http://Mrzhhh.github.io/2018/06/12/tensorflow读取本地图片数据的实现/","excerpt":"介绍本文主要介绍Tensorflow读取本地数据的方式，目前给出了将本地图片数据制作成类似于Cifar10二进制数据集的程序。其他数据导入方式持续更新中…","text":"介绍本文主要介绍Tensorflow读取本地数据的方式，目前给出了将本地图片数据制作成类似于Cifar10二进制数据集的程序。其他数据导入方式持续更新中… 将本地图片数据制作成相同于数据集Cifar10 - binary version的形式根据Cifar10数据集官网的描述，一张图片在二进制文件里存在的形式为（1Byte Label + 3072Byte Image），其中每个通道分别占有32 * 32 = 1024 个Byte. Data – a 10000x3072 numpy array of uint8s. Each row of the array stores a 32x32 colour image. The first 1024 entries contain the red channel values, the next 1024 the green, and the final 1024 the blue. The image is stored in row-major order, so that the first 32 entries of the array are the red channel values of the first row of the image.Labels – a list of 10000 numbers in the range 0-9. The number at index i indicates the label of the ith image in the array data. 完整程序如下： 123456789101112131415161718192021222324import osimport cv2import numpy as npimport timefile_dir = &quot;Your image dir&quot;for file in os.listdir(file_dir): img = cv2.imread(file_dir + file) img = cv2.resize(img,(32, 32)) if img is None: continue b = img[:,:,0].flatten() g = img[:,:,1].flatten() r = img[:,:,2].flatten() label = [0] out = np.array(list(label) + list(r) + list(g) + list(b),np.uint8) print(out) out.tofile(&quot;Your output dir&quot;)print(&quot;All set!&quot;)","categories":[{"name":"Technology","slug":"Technology","permalink":"http://Mrzhhh.github.io/categories/Technology/"}],"tags":[{"name":"Tensorflow","slug":"Tensorflow","permalink":"http://Mrzhhh.github.io/tags/Tensorflow/"}]},{"title":"MacOS下搭建Hexo静态博客","slug":"MacOS_Hexo","date":"2018-03-13T08:08:31.000Z","updated":"2018-03-13T21:13:56.760Z","comments":true,"path":"2018/03/13/MacOS_Hexo/","link":"","permalink":"http://Mrzhhh.github.io/2018/03/13/MacOS_Hexo/","excerpt":"介绍Hexo是一款静态博客框架，使用Hexo可以建立美观易用的个人博客，Hexo官方网站的介绍如下： Hexo is a fast, simple and powerful blog framework. You write posts in Markdown (or other languages) and Hexo generates static files with a beautiful theme in seconds. 本文讲解了在MacOS下Hexo的配置，使用Hexo进行写作并且部署到Github。可以实现本站博客的效果。","text":"介绍Hexo是一款静态博客框架，使用Hexo可以建立美观易用的个人博客，Hexo官方网站的介绍如下： Hexo is a fast, simple and powerful blog framework. You write posts in Markdown (or other languages) and Hexo generates static files with a beautiful theme in seconds. 本文讲解了在MacOS下Hexo的配置，使用Hexo进行写作并且部署到Github。可以实现本站博客的效果。 准备工作创建Repositories首先，在Github上免费注册自己的账号。通过阅读Guide，可以初步了解Github的使用。通过点击右上角➕，点击New repository 创建一个新的Repository。 在Repository name中填写username.github.io, 其中username为你的用户名，然后点击Create repository创建。 安装GIt我们将使用Homebrew安装Git, 如果没有安装Homebrew, 复制以下命令到命令行进行安装。 1$ /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install) 安装Homebrew后，在命令行使用brew install git安装Git，安装后输入brew list会出现git表示安装成功。 安装Node.js使用Homebrew安装Node.js，在命令行输入brew install node即可。1$ brew install node 配置SSH密钥创建SSH密钥首先查看一下是否已经有密钥，在命令行输入如下命令：123$ cd ~/.ssh$ lsid_rsa id_rsa.pub 若是显示出id_rsa和id_rsa.pub，则已经有了密钥，若是没有，在命令行输入以下命令创建密钥： 1$ ssh-keygen -t rsa -C &quot;your_email@youremail.com&quot; 成功后使用cd ~/.ssh进入文件夹，找到id_ras.pub文件并使用文本编辑器打开，复制其中内容。 提交公共秘钥id_rsa.pub即为你的公共秘钥，将从id_rsa.pub复制的内容添加到Github/settings/keys。 测试SSH密钥是否添加成功在命令行输入以下命令:1$ ssh -T git@github.com 输入你设置的密码，如果最后显示：You&#39;ve successfully authenticated, but GitHub does not provide shell access. 说明SHH密钥配置成功。 安装Hexo配置好Hexo所需要的环境后，可以进行Hexo的安装，在命令行输入以下命令：1$ npm install -g hexo-cli 安装完成后，进入你将要放置博客的文件夹,1$ cd &lt;folder&gt; *//将folder替换成文件夹所在路径* 然后输入以下命令：12$ hexo init$ npm install 到此，Hexo的博客就自动生成好了，可以在本地编辑内容，并且可以通过本地服务器查看，12hexo g *//生成博客页面，也可以用 hexo generate*hexo s *//启动本地服务器，可以通过localhost:4000访问页面，也可以用 hexo server* 在本地调试好博客后，我们需要将本地的博客上传到我们在github上创建的Repository上，进入博客目录，输入命令：1npm install hexo-deployer-git —save 安装完成后，打开博客目录内的_config.yml文件，将deploy：下的内容改为1234deploy: type: git repository: https://github.com/你的用户名/你的用户名.github.io.git branch: master 配置完成后，使用命令hexo d既可以将本地博客部署到Repository。 使用Hexo基本命令Hexo的常有基本命令有三条:123hexo clean //清除本地项目缓存hexo g //生成博客项目文件hexo d //将项目文件部署到服务器 全部命令介绍可移步官网命令介绍。 开始写一篇博客在博客文件夹下，输入命令 $ hexo new “Test”即可在博客文件夹下/source/_posts中新建一篇文章。在文章的首部，分别有title（标题），date（日期），tags（标签），categories（分类）等配置，在下方空白处可以直接进行写作。需要注意的是，写作需要使用Markdown语言，如果你对于Markdown语言不是很熟悉，现今有很多编辑支持输出Markdown格式语言（比如: Bear），方便快捷。12345678---title: Testdate: 2018-02-16 20:52:30tags: categories: Testcomments: true--- 当完成一篇博客，想将其部署到网络上，使用如下命令即可实现。123hexo clean //清除本地项目缓存hexo g //生成博客项目文件hexo d //将项目文件部署到服务器 主题安装本博客所使用的主题来自NexT，可以依据官方文档进行主题安装。若是想寻找更多主题，可以访问官方网站的主题部分。","categories":[{"name":"Technology","slug":"Technology","permalink":"http://Mrzhhh.github.io/categories/Technology/"}],"tags":[{"name":"Technology","slug":"Technology","permalink":"http://Mrzhhh.github.io/tags/Technology/"}]}]}
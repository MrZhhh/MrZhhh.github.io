{"meta":{"title":"ZX's Blog","subtitle":null,"description":"默默无闻的文艺青年的小博客","author":"ZX","url":"http://Mrzhhh.github.io"},"pages":[{"title":"[404 Not Found]","date":"2018-02-17T04:15:13.000Z","updated":"2018-02-17T04:26:19.000Z","comments":true,"path":"404.html","permalink":"http://Mrzhhh.github.io/404.html","excerpt":"","text":""},{"title":"ABOUT","date":"2018-02-17T04:15:13.000Z","updated":"2018-03-13T21:19:38.513Z","comments":false,"path":"about/index.html","permalink":"http://Mrzhhh.github.io/about/index.html","excerpt":"","text":"一个默默无闻的文艺青年。"},{"title":"CATEGORIES","date":"2018-02-19T02:16:52.000Z","updated":"2018-02-19T02:42:00.000Z","comments":false,"path":"categories/index.html","permalink":"http://Mrzhhh.github.io/categories/index.html","excerpt":"","text":""},{"title":"毕业一周年记","date":"2018-06-30T04:00:00.000Z","updated":"2018-07-04T07:20:16.232Z","comments":true,"path":"文章归档/2018-06-30-毕业一周年记.html","permalink":"http://Mrzhhh.github.io/文章归档/2018-06-30-毕业一周年记.html","excerpt":"","text":"一年前的今天，北京林业大学电气13-1班的同学们正式毕业。 当你们陆陆续续踏上归家的旅途时候，我才真正开始怀念这一去不复返的四年时光。 大一刚开学时候，第一次同学聚会是在学校小南门边儿上一家叫山林风的饭店，男生女生各坐一桌，现在想起那时候大家都特别拘谨的样子还很好笑。转眼已经毕业一年了，今年的六月份，还是那样的夏天，强烈的阳光伴随着热乎的空气，学校里在银杏大道一起拍照的好姐妹，整齐的穿着学士服在主楼前那个小道儿努力爬上草坪拍照的班级，毕业晚会和红毯，晚上还可以看到三两个喝多了回宿舍的好兄弟……整个校园都充斥着毕业的氛围，一切好像都和一年前一样，给人一种时光静止了的错觉。 我是后来才喜欢上摄影的。在旅行的时候，我不喜欢提着像相机这么重的东西，直到有一天当我在台湾的日月潭吹风，突然涌出了想要记录的冲动，我想记录我在不同的年龄怀着不同的心境走过的不同的地方。我要记录下想永久保存的那一刻，可能只有摄影才可以抓住像水一样流逝的时光。很幸运，在大学四年里，我们一起去了很多地方，并留下了很多可以承载回忆的照片。我们一起爬长城和滑雪，一起在火车上狼人杀，一起烧烤轰趴唱K，一起努力的准备合唱比赛和团日活动，一起努力的评选优良学风班，我们一起努力了快乐了太多，直到一起经历了毕业的那个六月的夏天。 也许大学毕业后二十啷当岁的这个年纪，正是逐渐步入社会的年纪。当我再次走在北林的校园里的时候，我感到有些怅然若失，我努力的思考为什么会有这种感觉，后来我才明白，我已经没有了专属于青春的无忧无虑，那种青春的义无反顾也许只属于大学时光吧。 去了美国读书之后才发现，背井离乡的时候最是想念朋友。我是一个不愿熟悉的感觉发生改变的人，我回国后就会找还在北京的同学一起吃饭喝酒，看到大家都没变样子的时候我最开心。可是还有很多同学，毕业之后再也没有见过。幸运的是，我们活在一个好的时代，我们可以通过微信群保持联系，从而得知了你们有的人离开了北京读硕士，有的人将要出国，有的人回到了自己的家乡，还有的人到了另一个城市工作。 随着成长，我们将要面对更多无力的困难，经历更多倔强后的妥协，学会隐藏起自己的梦想，不再追逐自己想要的自由，因为焦头烂额的工作之后还要填饱自己的肚子，照顾自己的生活。 踏入社会之后，对人情冷暖司空见惯，才发现弥足珍贵的是学生时代的那一片赤诚之心。 无论你们在天南地北，我最希望的，就是你们每一个人都能过得开心。 刚上大一时候老师就说“好好珍惜你们大一的聚会，因为等到以后就很难聚起来了”，然而我们大学四年已经数不清有几次喝醉在聚会上了。我对你们说过“我作为班长，最主要的任务就是带大家吃好玩好”。感谢大家和团支书，和我在大学时候一起完成了吃好玩好的主要任务。山长水远，前路漫漫。即便生活总是匆匆忙忙，也请大家一定要常联系，在受到来自同学聚会的召唤时，请记得一定要来见一见这些陪你走过青春的人儿啊！ 大家毕业一周年，快乐！ 致悠悠岁月中最斑斓的青春赵暄2018.6.30"},{"title":"TAGS","date":"2018-02-19T02:12:23.000Z","updated":"2018-02-19T02:41:42.000Z","comments":false,"path":"tags/index.html","permalink":"http://Mrzhhh.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Batch Normalization","slug":"BatchNormalization与tensorflow实现","date":"2018-07-02T04:00:00.000Z","updated":"2018-07-04T07:56:03.219Z","comments":true,"path":"2018/07/02/BatchNormalization与tensorflow实现/","link":"","permalink":"http://Mrzhhh.github.io/2018/07/02/BatchNormalization与tensorflow实现/","excerpt":"Batch Normalization - tensorflowtf.nn.momentstf.nn.moments( x, axes, shift=None, name=None, keep_dims=False)","text":"Batch Normalization - tensorflowtf.nn.momentstf.nn.moments( x, axes, shift=None, name=None, keep_dims=False) Args:x: A Tensor.axes: Array of ints. Axes along which to compute mean and variance.shift: Not used in the current implementationname: Name used to scope the operations that compute the moments.keep_dims: produce moments with the same dimensionality as the input. Returns:Two Tensor objects: mean and variance. 123456789import tensorflow as tfdef bn(x,name=&quot;bn&quot;): axes = [d for d in range(len(x.get_shape()))] beta = tf.get_variable(&quot;beta&quot;, shape=[],initializer=tf.constant_initializer(0.0)) gamma= tf.get_variable(&quot;gamma&quot;,shape=[],initializer=tf.constant_initializer(1.0)) x_mean,x_variance=tf.nn.moments(x,axes) y=tf.nn.batch_normalization(x,x_mean,x_variance,beta,gamma,1e-10,name) return y Referencehttps://www.jianshu.com/p/0312e04e4e83https://blog.csdn.net/vcvycy/article/details/78607351?locationNum=3&amp;fps=1","categories":[{"name":"Technology","slug":"Technology","permalink":"http://Mrzhhh.github.io/categories/Technology/"}],"tags":[{"name":"Tensorflow","slug":"Tensorflow","permalink":"http://Mrzhhh.github.io/tags/Tensorflow/"}]},{"title":"局部响应归一化","slug":"局部响应归一化与tensorflow实现","date":"2018-07-02T04:00:00.000Z","updated":"2018-07-04T07:51:34.039Z","comments":true,"path":"2018/07/02/局部响应归一化与tensorflow实现/","link":"","permalink":"http://Mrzhhh.github.io/2018/07/02/局部响应归一化与tensorflow实现/","excerpt":"局部相应归一化局部相应归一化出自论文ImageNet Classification with Deep Convolutional Neural Networks","text":"局部相应归一化局部相应归一化出自论文ImageNet Classification with Deep Convolutional Neural Networks @incollection{NIPS2012_4824,title = {ImageNet Classification with Deep Convolutional Neural Networks},author = {Alex Krizhevsky and Sutskever, Ilya and Hinton, Geoffrey E},booktitle = {Advances in Neural Information Processing Systems 25},editor = {F. Pereira and C. J. C. Burges and L. Bottou and K. Q. Weinberger},pages = {1097–1105},year = {2012},publisher = {Curran Associates, Inc.},url = {http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf}} 参数表示： i：代表下标，你要计算像素值的下标，从0计算起 j：平方累加索引，代表从j～i的像素值平方求和 x,y：像素的位置，公式中用不到 a：代表feature map里面的 i 对应像素的具体值 N：每个feature map里面最内层向量的列数 k：超参数，由原型中的blas指定 α：超参数，由原型中的alpha指定 n/2：超参数，由原型中的deepth_radius指定 β：超参数，由原型中的belta指定 局部响应归一化函数 - tensor flow tf.nn.local_response_normalization Aliases: tf.nn.local_response_normalization tf.nn.lrn 12345678tf.nn.local_response_normalization( input, depth_radius=5, bias=1, alpha=1, beta=0.5, name=None) Args:input: A Tensor. Must be one of the following types: half, bfloat16, float32. 4-D.depth_radius: An optional int. Defaults to 5. 0-D. Half-width of the 1-D normalization window.bias: An optional float. Defaults to 1. An offset (usually positive to avoid dividing by 0).alpha: An optional float. Defaults to 1. A scale factor, usually positive.beta: An optional float. Defaults to 0.5. An exponent.name: A name for the operation (optional). Returns:A Tensor. Has the same type as input.","categories":[{"name":"Technology","slug":"Technology","permalink":"http://Mrzhhh.github.io/categories/Technology/"}],"tags":[{"name":"Tensorflow","slug":"Tensorflow","permalink":"http://Mrzhhh.github.io/tags/Tensorflow/"}]},{"title":"从人脸图片库中筛选正脸姿态图片","slug":"从人脸图片库中筛选正脸姿态图片","date":"2018-06-27T04:00:00.000Z","updated":"2018-06-27T07:02:46.026Z","comments":true,"path":"2018/06/27/从人脸图片库中筛选正脸姿态图片/","link":"","permalink":"http://Mrzhhh.github.io/2018/06/27/从人脸图片库中筛选正脸姿态图片/","excerpt":"介绍本文主要介绍一个小工具，其功能是在具有各种姿态（各个角度的转头）的人脸图片库中筛选出正脸的图片。","text":"介绍本文主要介绍一个小工具，其功能是在具有各种姿态（各个角度的转头）的人脸图片库中筛选出正脸的图片。 环境需求SeetaFace人脸识别库OpenCV 基本方法首先使用OpenCV的glob遍历文件夹里的图片，然后对每张图片提取脸部特征。以下这段代码为提取脸部特征点，如图所示： 图片引用自SeetaFace2 Alignment 1234567891011121314151617181920212223242526272829Mat frame = imread(fn[i]); if (!frame.data) &#123; continue; &#125; images.push_back(frame); seeta::FaceDetector2 FD(&quot;bindata/SeetaFaceDetector2.0.ats&quot;); seeta::cv::ImageData image = frame; seeta::PointDetector2 PD(&quot;bindata/SeetaPointDetector2.0.pts5.ats&quot;); int num; SeetaRect *face = FD.Detect(image, &amp;num); if (num==0) &#123; continue; &#125; SeetaPointF *points = PD.Detect(image, *face); if (points) &#123; std::cout &lt;&lt; &quot;Points: [&quot; &lt;&lt; std::endl; for (int j = 0; j &lt; PD.LandmarkNum(); ++j) &#123; std::cout &lt;&lt; &quot;(&quot; &lt;&lt; points[j].x &lt;&lt; &quot;, &quot; &lt;&lt; points[j].y &lt;&lt; &quot;),&quot; &lt;&lt; std::endl; &#125; std::cout &lt;&lt; &quot;]&quot; &lt;&lt; std::endl; &#125; 然后计算点3是否为点1和点二的中点，如果是的话，则判断为正脸照片。 123456789double result = 2 * points[2].x - points[0].x - points[1].x; result = fabs(result); if (result &lt; s) &#123; s = result; std::cout &lt;&lt; s &lt;&lt; std::endl; string Img_Name = &quot;D:/Desktop/pachong/result/&quot; + to_string(s) + &quot;.jpg&quot;; imwrite(Img_Name, frame); &#125; 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;seeta/FaceDetector2.h&gt;#include&lt;seeta/PointDetector2.h&gt;#include&lt;seeta/FaceRecognizer.h&gt;#include&lt;opencv2/opencv.hpp&gt;#include&lt;seeta/Struct_cv.h&gt;#include&lt;iostream&gt;#include&lt;io.h&gt;#include&lt;string&gt;#include&lt;vector&gt;using namespace std;using namespace cv;void main()&#123; vector&lt;Mat&gt; read_images_in_folder(cv::String pattern); cv::String pattern = &quot;你的图片文件路径&quot;; vector&lt;Mat&gt; images = read_images_in_folder(pattern);&#125;std::vector&lt;Mat&gt; read_images_in_folder(cv::String pattern)&#123; vector&lt;cv::String&gt; fn; glob(pattern, fn, false); cout &lt;&lt; &quot;pattern&quot;&lt;&lt;pattern &lt;&lt; endl; vector&lt;Mat&gt; images; size_t count = fn.size(); cout &lt;&lt; count &lt;&lt; endl; double s = 20; int pick_img = 0; for (size_t i = 0; i &lt; count; i++) &#123; Mat frame = imread(fn[i]); if (!frame.data) &#123; continue; &#125; images.push_back(frame); seeta::FaceDetector2 FD(&quot;bindata/SeetaFaceDetector2.0.ats&quot;); seeta::cv::ImageData image = frame; seeta::PointDetector2 PD(&quot;bindata/SeetaPointDetector2.0.pts5.ats&quot;); int num; SeetaRect *face = FD.Detect(image, &amp;num); if (num==0) &#123; continue; &#125; SeetaPointF *points = PD.Detect(image, *face); if (points) &#123; std::cout &lt;&lt; &quot;Points: [&quot; &lt;&lt; std::endl; for (int j = 0; j &lt; PD.LandmarkNum(); ++j) &#123; std::cout &lt;&lt; &quot;(&quot; &lt;&lt; points[j].x &lt;&lt; &quot;, &quot; &lt;&lt; points[j].y &lt;&lt; &quot;),&quot; &lt;&lt; std::endl; &#125; std::cout &lt;&lt; &quot;]&quot; &lt;&lt; std::endl; &#125; double result = 2 * points[2].x - points[0].x - points[1].x; result = fabs(result); if (result &lt; s) &#123; s = result; std::cout &lt;&lt; s &lt;&lt; std::endl; string Img_Name = &quot;D:/Desktop/pachong/result/&quot; + to_string(s) + &quot;.jpg&quot;; imwrite(Img_Name, frame); &#125; &#125; return images;&#125;","categories":[{"name":"Technology","slug":"Technology","permalink":"http://Mrzhhh.github.io/categories/Technology/"}],"tags":[{"name":"Face Recognition","slug":"Face-Recognition","permalink":"http://Mrzhhh.github.io/tags/Face-Recognition/"}]},{"title":"Tensorflow读取本地图片数据的实现","slug":"tensorflow读取本地图片数据的实现","date":"2018-06-12T21:30:31.000Z","updated":"2018-06-12T09:30:44.607Z","comments":true,"path":"2018/06/12/tensorflow读取本地图片数据的实现/","link":"","permalink":"http://Mrzhhh.github.io/2018/06/12/tensorflow读取本地图片数据的实现/","excerpt":"介绍本文主要介绍Tensorflow读取本地数据的方式，目前给出了将本地图片数据制作成类似于Cifar10二进制数据集的程序。其他数据导入方式持续更新中…","text":"介绍本文主要介绍Tensorflow读取本地数据的方式，目前给出了将本地图片数据制作成类似于Cifar10二进制数据集的程序。其他数据导入方式持续更新中… 将本地图片数据制作成相同于数据集Cifar10 - binary version的形式根据Cifar10数据集官网的描述，一张图片在二进制文件里存在的形式为（1Byte Label + 3072Byte Image），其中每个通道分别占有32 * 32 = 1024 个Byte. Data – a 10000x3072 numpy array of uint8s. Each row of the array stores a 32x32 colour image. The first 1024 entries contain the red channel values, the next 1024 the green, and the final 1024 the blue. The image is stored in row-major order, so that the first 32 entries of the array are the red channel values of the first row of the image.Labels – a list of 10000 numbers in the range 0-9. The number at index i indicates the label of the ith image in the array data. 完整程序如下： 123456789101112131415161718192021222324import osimport cv2import numpy as npimport timefile_dir = &quot;Your image dir&quot;for file in os.listdir(file_dir): img = cv2.imread(file_dir + file) img = cv2.resize(img,(32, 32)) if img is None: continue b = img[:,:,0].flatten() g = img[:,:,1].flatten() r = img[:,:,2].flatten() label = [0] out = np.array(list(label) + list(r) + list(g) + list(b),np.uint8) print(out) out.tofile(&quot;Your output dir&quot;)print(&quot;All set!&quot;)","categories":[{"name":"Technology","slug":"Technology","permalink":"http://Mrzhhh.github.io/categories/Technology/"}],"tags":[{"name":"Tensorflow","slug":"Tensorflow","permalink":"http://Mrzhhh.github.io/tags/Tensorflow/"}]},{"title":"MacOS下搭建Hexo静态博客","slug":"MacOS_Hexo","date":"2018-03-13T20:08:31.000Z","updated":"2018-03-13T21:13:56.760Z","comments":true,"path":"2018/03/13/MacOS_Hexo/","link":"","permalink":"http://Mrzhhh.github.io/2018/03/13/MacOS_Hexo/","excerpt":"介绍Hexo是一款静态博客框架，使用Hexo可以建立美观易用的个人博客，Hexo官方网站的介绍如下： Hexo is a fast, simple and powerful blog framework. You write posts in Markdown (or other languages) and Hexo generates static files with a beautiful theme in seconds. 本文讲解了在MacOS下Hexo的配置，使用Hexo进行写作并且部署到Github。可以实现本站博客的效果。","text":"介绍Hexo是一款静态博客框架，使用Hexo可以建立美观易用的个人博客，Hexo官方网站的介绍如下： Hexo is a fast, simple and powerful blog framework. You write posts in Markdown (or other languages) and Hexo generates static files with a beautiful theme in seconds. 本文讲解了在MacOS下Hexo的配置，使用Hexo进行写作并且部署到Github。可以实现本站博客的效果。 准备工作创建Repositories首先，在Github上免费注册自己的账号。通过阅读Guide，可以初步了解Github的使用。通过点击右上角➕，点击New repository 创建一个新的Repository。 在Repository name中填写username.github.io, 其中username为你的用户名，然后点击Create repository创建。 安装GIt我们将使用Homebrew安装Git, 如果没有安装Homebrew, 复制以下命令到命令行进行安装。 1$ /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install) 安装Homebrew后，在命令行使用brew install git安装Git，安装后输入brew list会出现git表示安装成功。 安装Node.js使用Homebrew安装Node.js，在命令行输入brew install node即可。1$ brew install node 配置SSH密钥创建SSH密钥首先查看一下是否已经有密钥，在命令行输入如下命令：123$ cd ~/.ssh$ lsid_rsa id_rsa.pub 若是显示出id_rsa和id_rsa.pub，则已经有了密钥，若是没有，在命令行输入以下命令创建密钥： 1$ ssh-keygen -t rsa -C &quot;your_email@youremail.com&quot; 成功后使用cd ~/.ssh进入文件夹，找到id_ras.pub文件并使用文本编辑器打开，复制其中内容。 提交公共秘钥id_rsa.pub即为你的公共秘钥，将从id_rsa.pub复制的内容添加到Github/settings/keys。 测试SSH密钥是否添加成功在命令行输入以下命令:1$ ssh -T git@github.com 输入你设置的密码，如果最后显示：You&#39;ve successfully authenticated, but GitHub does not provide shell access. 说明SHH密钥配置成功。 安装Hexo配置好Hexo所需要的环境后，可以进行Hexo的安装，在命令行输入以下命令：1$ npm install -g hexo-cli 安装完成后，进入你将要放置博客的文件夹,1$ cd &lt;folder&gt; *//将folder替换成文件夹所在路径* 然后输入以下命令：12$ hexo init$ npm install 到此，Hexo的博客就自动生成好了，可以在本地编辑内容，并且可以通过本地服务器查看，12hexo g *//生成博客页面，也可以用 hexo generate*hexo s *//启动本地服务器，可以通过localhost:4000访问页面，也可以用 hexo server* 在本地调试好博客后，我们需要将本地的博客上传到我们在github上创建的Repository上，进入博客目录，输入命令：1npm install hexo-deployer-git —save 安装完成后，打开博客目录内的_config.yml文件，将deploy：下的内容改为1234deploy: type: git repository: https://github.com/你的用户名/你的用户名.github.io.git branch: master 配置完成后，使用命令hexo d既可以将本地博客部署到Repository。 使用Hexo基本命令Hexo的常有基本命令有三条:123hexo clean //清除本地项目缓存hexo g //生成博客项目文件hexo d //将项目文件部署到服务器 全部命令介绍可移步官网命令介绍。 开始写一篇博客在博客文件夹下，输入命令 $ hexo new “Test”即可在博客文件夹下/source/_posts中新建一篇文章。在文章的首部，分别有title（标题），date（日期），tags（标签），categories（分类）等配置，在下方空白处可以直接进行写作。需要注意的是，写作需要使用Markdown语言，如果你对于Markdown语言不是很熟悉，现今有很多编辑支持输出Markdown格式语言（比如: Bear），方便快捷。12345678---title: Testdate: 2018-02-16 20:52:30tags: categories: Testcomments: true--- 当完成一篇博客，想将其部署到网络上，使用如下命令即可实现。123hexo clean //清除本地项目缓存hexo g //生成博客项目文件hexo d //将项目文件部署到服务器 主题安装本博客所使用的主题来自NexT，可以依据官方文档进行主题安装。若是想寻找更多主题，可以访问官方网站的主题部分。","categories":[{"name":"Technology","slug":"Technology","permalink":"http://Mrzhhh.github.io/categories/Technology/"}],"tags":[{"name":"Technology","slug":"Technology","permalink":"http://Mrzhhh.github.io/tags/Technology/"}]}]}